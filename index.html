<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>CityJSON viewer</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<link rel="stylesheet" href="./css/cityjson.css">
		<div class="pageHead">
			<div class="dropboxBox">
  				<form id="dropbox" class="my-form">
					<p class="dbText">Drop your CityJSON file here!</p>
					<input type="file" id="fileElem" onchange="handleFiles(this.files)">
			</div>
			<!-- <div class="switchBox">
				<label class="switch">
					<input type="checkbox" id="wireframeBox" onclick="wireframeFunc()"> <p class="dbText"> Display wireframe geometry </p>
					<span class="slider round"></span>
				</label>
			</div> -->
		</div>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/jquery-3.3.1.min.js"></script>
		<script>module = {}</script>
		<script src="js/earcut.js"></script>
		<script>
			
			// Handle the dropped CityJSON file
			function jsonGetter (url) {
				"use strict"

				// Create new geometry for the new mesh
				var geom = new THREE.Geometry();

				$.getJSON(url, function (json) {
					
					// Remove old geometry from scene
					while(scene.children.length > 0){ 
					    scene.remove(scene.children[0]); 
					};

					// Add vertices to geometry
					for (var i = 0; i < json.vertices.length; i++) {
						geom.vertices.push( new THREE.Vector3 (
							json.vertices[i][0],
							json.vertices[i][1],
							json.vertices[i][2]));
					}

					var objColors = {
						"Building": 0xcc0000,
						"BuildingPart": 0xcc0000,
						"BuildingInstallation": 0xcc0000,
						"Bridge": 0x999999,
						"BridgePart": 0x999999,
						"BridgeInstallation": 0x999999,
						"BridgeConstructionElement": 0x999999,
						"CityObjectGroup": 0xffffb3,
						"CityFurniture": 0xcc0000,
						"GenericCityObject": 0xcc0000,
						"LandUse": 0xffffb3,
						"PlantCover": 0x39ac39,
						"Railway": 0x000000,
						"Road": 0x999999,
						"SolitaryVegetationObject": 0x39ac39,
						"TINRelief": 0x39ac39,
						"TransportSquare": 0x999999,
						"Tunnel": 0x999999,
						"TunnelPart": 0x999999,
						"TunnelInstallation": 0x999999,
						"WaterBody": 0x4da6ff
					};
					var faceCounter = 0;
					// Add faces to geometry
					for (var cityObj in json.CityObjects){

						var coType = json.CityObjects[cityObj].type;

						for (var geomNum = 0; geomNum < json.CityObjects[cityObj].geometry.length; geomNum++) {

							if (json.CityObjects[cityObj].geometry[geomNum].type == ("MultiSurface" || "CompositeSurface")) {

								for (var j = 0; j < json.CityObjects[cityObj].geometry[geomNum].boundaries.length; j++) { 
 							  	console.log(json.CityObjects[cityObj].geometry[geomNum].boundaries[j][0].length); 
 							  	//-- triangulate exterior ring
 							  	let v = [];
 							  	for (var k = 0; k < json.CityObjects[cityObj].geometry[geomNum].boundaries[j][0].length; k++) {
 							  		var i = json.CityObjects[cityObj].geometry[geomNum].boundaries[j][0][k];
 							  		v.push({index: i, vertex: json.vertices[i]});
 							  	}
 							  	if (v.length == 3) {
 							  		geom.faces.push( new THREE.Face3(
											v[0]['index'],
											v[1]['index'],
											v[2]['index']
										));
										var currentFace = geom.faces[ faceCounter ];
										currentFace.color.setHex( objColors[coType] );
										faceCounter += 1;
										continue;
 							  	}
 							  	else if (v.length == 4) {
 							  		geom.faces.push( new THREE.Face3(
											v[0]['index'],
											v[1]['index'],
											v[2]['index']
										));
										var currentFace = geom.faces[ faceCounter ];
										currentFace.color.setHex( objColors[coType] );
										faceCounter += 1;
										geom.faces.push( new THREE.Face3(
											v[0]['index'],
											v[2]['index'],
											v[3]['index']
										));
										var currentFace = geom.faces[ faceCounter ];
										currentFace.color.setHex( objColors[coType] );
										faceCounter += 1;
										continue;
 							  	}
 							  	// console.log(v);
 							  	var n = get_normal_newell(v);
 							  	// console.log("->", n);
 							  	let pv = []; //-- project vertices
 							  	for (var i = 0; i < v.length; i++) {
 							  		var ptmp = new THREE.Vector3(v[i]['vertex'][0], v[i]['vertex'][1], v[i]['vertex'][2]);
										
										var re = to_2d(ptmp, n);
										// console.log("2d:", re);
										
										pv.push(re['x']);
										pv.push(re['y']);
 							  	};
 							  	console.log("re:", pv);
 							  	//-- triangulate with mapbox.earcut
 							  	var tr = earcut(pv, null, 2);
 							  	console.log("tr:", tr);

 							  	for (var i = 0; i < tr.length; i += 3) {
	 							  	geom.faces.push( new THREE.Face3(
											v[tr[i]]['index'],
											v[tr[i+1]]['index'],
											v[tr[i+2]]['index']
										));
										var currentFace = geom.faces[ faceCounter ];
										currentFace.color.setHex( objColors[coType] );
										faceCounter += 1;
									};


								};
							};
							
							if (json.CityObjects[cityObj].geometry[geomNum].type == "Solid") {

								for (var k = 0; k < json.CityObjects[cityObj].geometry[geomNum].boundaries[0].length; k++) {
									geom.faces.push( new THREE.Face3(
										json.CityObjects[cityObj].geometry[geomNum].boundaries[0][k][0][0],
										json.CityObjects[cityObj].geometry[geomNum].boundaries[0][k][0][1],
										json.CityObjects[cityObj].geometry[geomNum].boundaries[0][k][0][2]
									));
									var currentFace = geom.faces[ faceCounter ];
									currentFace.color.setHex( objColors[coType] );
									faceCounter += 1;
								};

							};

							if (json.CityObjects[cityObj].geometry[geomNum].type == ("MultiSolid" || "CompositeSolid")) {

								for (var l = 0; l < json.CityObjects[cityObj].geometry[geomNum].boundaries.length; l++) {
									for (var m = 0; m < json.CityObjects[cityObj].geometry[geomNum].boundaries[l][0].length; m++) {
										geom.faces.push( new THREE.Face3(
											json.CityObjects[cityObj].geometry[geomNum].boundaries[l][0][m][0][0],
											json.CityObjects[cityObj].geometry[geomNum].boundaries[l][0][m][0][1],
											json.CityObjects[cityObj].geometry[geomNum].boundaries[l][0][m][0][2]
										));
										var currentFace = geom.faces[ faceCounter ];
										currentFace.color.setHex( objColors[coType] );
										faceCounter += 1;
									};
								};
							};	
						};
					
					};

					// Material for mesh
					var material = new THREE.MeshBasicMaterial( {
				        vertexColors: THREE.VertexColors,
				    	flatShading: THREE.FlatShading,
				        polygonOffset: true,
				        polygonOffsetFactor: 1, // positive value pushes polygon further away
				        polygonOffsetUnits: 1
				    } );

					// Add mesh to scene
					var mymesh = new THREE.Mesh(geom, material);					
					mymesh.material.side = THREE.DoubleSide;
					mymesh.geometry.normalize();
					mymesh.name = "CJMesh"
					scene.add(mymesh);
					
					// Add wireframe
					// var currentMesh = scene.getObjectByName( "CJMesh" );
					var geo = new THREE.EdgesGeometry( mymesh.geometry ); 
					var mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: .1, transparent: true, opacity: 0.2 } );
			    var wireframe = new THREE.LineSegments( geo, mat );
			    wireframe.name = "wireframe"
			    scene.add( wireframe );
			    renderer.render(scene, camera);			    
					
				  // Reposition camera	
				  camera.position.set(0, 0, 2);
				  camera.lookAt(0, 0, 0);

				  // Render & orbit controls
					var controls = new THREE.OrbitControls( camera, renderer.domElement );
					controls.target.set(0, 0, 0);
					controls.addEventListener( 'change', function() { renderer.render(scene, camera); } ); 
					renderer.render(scene, camera);
				});
			};

			// Wireframe checkbox function
			function wireframeFunc() {
	      // Add edges
	      var currentMesh = scene.getObjectByName( "CJMesh" );
				var geo = new THREE.EdgesGeometry( currentMesh.geometry ); 
				var mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: .1, transparent: true, opacity: 0.2 } );
		    var wireframe = new THREE.LineSegments( geo, mat );
		    wireframe.name = "wireframe"
		    scene.add( wireframe );
		    renderer.render(scene, camera);
			};


      function get_normal_newell(poly) {
        // find normal with Newell's method
        // console.log("poly:", poly);
        var n = [0.0, 0.0, 0.0];
        // if len(poly) == 0:
        //     print ("NOPOINTS")
        for (var i = 0; i < poly.length; i++) {
          var nex = i + 1;
          if ( nex == poly.length) {
            nex = 0;
          };
          n[0] = n[0] + ( (poly[i]['vertex'][1] - poly[nex]['vertex'][1]) * (poly[i]['vertex'][2] + poly[nex]['vertex'][2]) );
          n[1] = n[1] + ( (poly[i]['vertex'][2] - poly[nex]['vertex'][2]) * (poly[i]['vertex'][0] + poly[nex]['vertex'][0]) );
          n[2] = n[2] + ( (poly[i]['vertex'][0] - poly[nex]['vertex'][0]) * (poly[i]['vertex'][1] + poly[nex]['vertex'][1]) );
      	};
        var b = new THREE.Vector3(n[0], n[1], n[2]);
        return b.normalize();
    	};

    	function to_2d(p, n) {
		    // n must be normalised
		    // p = np.array([1, 2, 3])
		    // newell = np.array([1, 3, 4.2])
		    // n = newell/sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2])
				var x3 = new THREE.Vector3(1.1, 1.1, 1.1);
				if ( x3.distanceTo(n) < 0.01 ) {
					x3.add(new THREE.Vector3(1.0, 2.0, 3.0));
				}	    	
				var tmp = x3.dot(n);
				var tmp2 = n.clone();
				tmp2.multiplyScalar(tmp);
				x3.sub(tmp2);
				x3.normalize();
				var y3 = n.clone();
				y3.cross(x3);
				let x = p.dot(x3);
				let y = p.dot(y3);
				var re = {x: x, y: y};
				return re;
	    }


			// Dropbox functions
			var dropbox;
			dropbox = document.getElementById("dropbox");
			dropbox.addEventListener("dragenter", dragenter, false);
			dropbox.addEventListener("dragover", dragover, false);
			dropbox.addEventListener("drop", drop, false);

			['dragover'].forEach(eventName => {
			  dropbox.addEventListener(eventName, highlight, false)
			})

			;['dragleave', 'drop'].forEach(eventName => {
			  dropbox.addEventListener(eventName, unhighlight, false)
			})

			function highlight(e) {
			  dropbox.classList.add('highlight')
			}

			function unhighlight(e) {
			  dropbox.classList.remove('highlight')
			}

			function dragenter(e) {
			  e.stopPropagation();
			  e.preventDefault();
			}

			function dragover(e) {
			  e.stopPropagation();
			  e.preventDefault();
			}

			function drop(e) {
			  e.stopPropagation();
			  e.preventDefault();

			  var dt = e.dataTransfer;
			  var files = dt.files;

			  handleFiles(files);
			}

			function handleFiles(files) {
				var jsonfile = files[0]
				var objectURL = window.URL.createObjectURL(jsonfile);
				jsonGetter(objectURL)
			}

			// Initiate scene, camera, renderer
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(
			    60,                                   // Field of view
			    window.innerWidth/window.innerHeight, // Aspect ratio
			    0.1,                                  // Near clipping pane
			    10000                                  // Far clipping pane
			);

			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xFFFFFF );
			document.body.appendChild( renderer.domElement );
			renderer.render(scene, camera);
			
		</script>
	</body>
</html>